\begin{itemize}
  \item Se trabaja con sistemas críticos y reactivos, esto implica que si fallan, ponen en riesgo la vida de las personas, y que están reaccionando a \textbf{eventos del entorno}
  \item Se elije modelar para poder usar herramientas matemáticas que permitan corroborar la correctitud del modelo en cuestión
  \begin{itemize}
    \item Porque el testing no es suficiente
    \item El testing puede confirmar la presencia de errores, pero no garantizar su ausencia
    \item Automatización tampoco es posible por la explosión de estados
  \end{itemize}
  \item Se usan redes de petri porque tienen bastante expresividad: muestran estados globales, y los locales de cada una de las partes
\end{itemize}

El problema de los programas concurrentes es que tenemos más de un proceso, hilo o componente que interactúan entre sí, para lograr un objetivo en común. Por el no determinismo de los planificadores de los SOs, es imposible conocer el orden en el que se van a ejecutar las trazas de c/parte.

Como se encuentran accediendo a recursos compartidos, hay que garantizar que las cosas se realicen en cierto orden, para que el objetivo global del programa pueda cumplirse.

Por esto, aparecen ciertos problemas:
\begin{itemize}
  \item \textbf{Violación de propiedades universales}: Valores que deberían permanecer constantes, o en un intervalo determinado, pueden variar fuera de sus valores permitidos según el orden en que sean leídos y escritos.
  \item \textbf{Starvation}: Una parte se queda esperando indefinidamente que suceda algo, y no ejecuta nada
  \item \textbf{Deadlock}: dos o más procesos quedan esperando mutuamente el avance del otro. Si yo tengo un archivo y quiero abrir otro, pero otro proceso tiene ese archivo y está esperando que yo libere el mío, los dos nos vamos a bloquear
  \item \textbf{Problemas de uso no exclusivo}: corrupción de un recurso. Es similar al primero, pero no necesariamente tiene que haber una invariante que sea violada
  \item \textbf{Livelock}: es similar al deadlock, pero en vez de quedarse esperando indefinidamente, los dos liberan el recurso que tienen y lo vuelven a tomar cuando el otro proceso hace lo mismo, quedando "trabados" en una sección del programa
\end{itemize}

\subsection{Semántica de los programas concurrentes}
Un sistema concurrente está basado en un sistema de transición de estado, que es un grafo dirigido en el cual:
\begin{itemize}
  \item Los nodos son los estados del sistema
  \item Las aristas son las transiciones \textbf{atómicas} entre estados
  \item Hay un nodo distinguido, que se reconoce como el estado inicial del sistema
\end{itemize}

La \textbf{relación de transición de un sistema} me indica cómo son las transiciones de estado, según los eventos que me lleguen.

La \textbf{traza del sistema} es la secuencia de estados para una ejecución particular. Como los procesos concurrentes se ejecutan intercalando acciones atómicas, la traza de estos va a presentar interleaving la cual va a ser no determinista. Muchos interleavings me pueden llevar a los mismos estados globales.

Para un programa ``real'', el conjunto de estados está dado por la combinación de los valores de todas las variables globales, así como el valor de unas variables implícitas: el program counter de cada uno de los procesos.

\subsection{Proceso}
Es una ``unidad de actividad'' (un trozo de un programa) que se caracteriza por la ejecución de una secuencia de instrucciones, un estado actual, y un conjunto de recursos del sistema asociados.

Tiene 5 estados:
\begin{enumerate}
  \item Nonato
  \item Activo
  \item Preparado
  \item Bloqueado. Es este estado puede también estar suspendido, que es cuando el SO lo baja al disco para liberar memoria para otros procesos que puedan ejecutar alguna tarea. En este caso, podremos tener 2 estados más:
    \begin{enumerate}
      \item Bloqueado: todavía no sucede el evento que está esperando
      \item Preparado: el evento ya sucedió, y está listo para volver a ser cargado en memoria a espera de tiempo de CPU
    \end{enumerate}
  \item Muerto
\end{enumerate}

El control de procesos se hace a través de un registro llamado BCP, donde se tiene toda la información necesaria para esto. Dicha información está compuesta por:
\begin{itemize}
  \item PID
  \item Estado (ver arriba)
  \item Contador de programa
  \item Valores de registro de CPU, para los cambios de contexto
  \item Espacio de direcciones de memoria
  \item Prioridad para la planificación
  \item Lista de recursos asignados (fds, sockets)
  \item Estadísticas del proceso para manejo del SO
  \item Datos del propietario
  \item Permisos asignados
  \item Señales pendientes de ser servidas
\end{itemize}

\subsection{Hilos}
\begin{itemize}
  \item Surgen porque es más ``barato'' cambiar de hilo que de proceso.
  \item Cada hilo tiene un PC, una pila de ejecución y el estado de la CPU. 
  \item Comparten espacios de direcciones y datos.
  \item El proceso sigue en ejecución mientras al menos uno de sus hilos siga activo.
\end{itemize}

Tienen los siguientes estados:
\begin{enumerate}
  \item Creación
  \item Bloqueo
  \item Desbloqueo
  \item Temrinación
  \item Waiting
  \item Sleeping
\end{enumerate}

El pasaje entre estados, y la finalidad de cada uno, es análogo al de los procesos.

Es mucho más rápida la creación, la destrucción, y la conmutación de hilos. Además, la comunicación entre hilos no necesita llamar al núcleo.
